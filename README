# 1st System Programming Assignment 2020
**D. Alexandres, 1115201400006.**
First (1st) assignment on UNIX system programming,
*University of Athens, 2020.*

ΠΡΟΣΑΡΜΟΣΤΗΚΕ ΣΤΟ ΣΚΡΙΠΤ ΠΡΙΝΤ ΦΟΡΜΑΤ ΕΚΤΟΣ ΑΠΟ ΤΗ RECORDPATIENTEXIT
ΑΥΤΗ ΔΙΝΕΙ ΤΟ ΣΩΣΤΟ ΜΗΝΥΜΑ ΕΝΗΜΕΡΩΣΗΣ ΑΛΛΑ ΕΑΝ ΥΠΑΡΧΕΙ ΗΔΗ EXITDATE ΤΟ ΚΑΝΕΙ OVERWRITE ΕΦΟΣΟΝ ΑΥΤΟ ΔΕΝ ΕΙΝΑΙ ΝΩΡΙΤΕΡΟ ΤΟΥ ENTRYDATE ΤΟΥ.
ΤΟ README ΠΡΕΠΕΙ ΝΑ ΔΙΑΒΑΣΤΕΙ ΟΜΩΣ.

Υλοποιήθηκε με C++ σε Ubuntu 16.04 LTS και δοκιμάστηκε σε μηχάνημα στης σχολής.
Δοκιμάστηκε και στα 2 μηχανήματα (προσωπικό και σχολής) με valgrind ακόμη και με πλήθος εγγραφων = 30000
και ΔΕΝ υπήρξαν memory leaks κατά το /exit.
Να σημειωθεί ότι λόγω bug του valgrind με τον compiler της c++ εμφανίζει ένα still reachable
σταθερού μεγέθους το οποίο αναφέρθηκε και στο piazza αλλά και στο ίδιο το valgrind FAQ ότι δεν είναι δικό μου πρόβλημα.

#ENTOLH METAGLWTTISHS
make
#ENTOLH EKTELSHS
Ίδια με της εκφώνησης (ή make run αν επιθυμεί ο χρήστης να ορίσει παραμέτρους στο makefile και να το τρέχει απο κει)

ΟΛΑ τα ερωτήματα έχουν υλοποιηθεί.
Αρχικά ελέγχονται τα ορίσματα που έδωσε ο χρήστης στη γραμμή εντολών και γίνονται οι κατάλληλες αναθέσεις.
Διαβάζονται οι εγγραφές από το αρχείο εισόδου και ισχύουν όσα λέει η εκφώνηση.
Ο κώδικας είναι γεμάτος από επεξηγηματικά σχόλια !!.
Όλες οι κλάσεις που ζητά η εκφώνηση ως ελάχιστες (οι 2 hashtables για χώρα/ασθένεια, το δέντρο, ο σωρός) υλοποιούνται κανονικά.

ΠΑΡΑΚΑΛΩ ΔΙΑΒΑΣΤΕ ΤΙΣ ΕΞΗΣ ΠΑΡΑΔΟΧΕΣ:

Απορρίπτονται εγγραφές με λιγότερα ή περισσότερα από 7 (επτά) γνωρίσματα:
1.recordID, 2.patientFirstName, 3.patientLastName, 4.diseaseID, 5.country, 6.entryDate, 7.exitDate (που μπορεί ασφαλώς να είναι παύλα.)
Οποιαδήποτε εγγραφή δεν ακολουθεί αυτό το μοτίβο αγνοείται.

Όπως ειπώθηκε και στο piazza, στο bucketSize περιλαμβάνεται
και ο δείκτης στο επόμενο bucket ΚΑΙ ο βοηθητικός ακέραιος που κρατάω εγώ.

Όποιο και να είναι το bucketSize, δε γίνεται ο αριθμός κόμβων σε blocks να είναι 0. Θα είναι τουλάχιστον 1.

Ημερομηνίες αποκλειστικά σε μορφή DD-MM-YY. Ο,τιδήποτε άλλο θα απορρίπτεται.
Ασφαλώς και επιτρέπονται ημερομηνίες μεγαλύτερες της τωρινής.
Σκοπός της εφαρμογής είναι να είναι ενα πολύτιμο και χρηστικό ευρετήριο για οποιοδήποτε κατάλληλα
διαμορφωμένο Dataset επομένως πρέπει και μελλοντικές ημερομηνίες να γίνονται δεκτές.
Πρέπει να γίνεται σεβαστό το οτι οι ημερομηνίες πρέπει να αποτελούνται απο αριθμούς.
Εάν έχουν γράμματα, η εφαρμογή τερματίζει λόγω της stoi() που κάνει error handling.

ΣΗΜΑΝΤΙΚΟ: για τα ορίσματα date1 date2 ακολουθείται η προσέγγιση που αναφέρει στο piazza ο instructor Ioannis Kalyvas και είναι η :
"να βρεις τα records στα οποία το entry date είναι μικρότερο από το date2.
 Στην συνέχεια για όσα records έκαναν qualify πετάς όσα το exit date είναι μικρότερο από το date1".
Επίσης δε μπορεί να δοθεί - ως όρισμα ενός date γιατί η εκφώνηση λέει αν είναι το ένα ορισμένο πρέπει να είναι και το άλλο.

Τα ορίσματα των εντολών χωρίζονται μεταξύ τους με κενά, όπως στην εκφώνηση.
Εντολές με tabs, extra spaces, \r ή άλλα whitespace shenanigans τα χειρίζεται σωστά
αλλά προτιμητέο θα ήταν να γίνεται σεβαστό το space delimiting των ορισμάτων των εντολών.

Στα δέντρα για το θέμα της ίδιας entryDate,
διατηρώ λίστα στον κόμβο του δέντρου με δείκτες στις εγγραφές που έχουν αυτήν την ημερομηνία.


Στη /recordPatientExit:
  -ελέγχεται η ημερομηνία που δίνει ο χρήστης να είναι ορθή.
  -Με if δίνεται μήνυμα λάθους σε περίπτωση που δοθεί '-' ως exit date γιατί διευκρινιστηκε στο piazza.
  -εάν η εγγραφή με το δοθέν ID δεν υπάρχει, η εντολή αγνοείται με σχετικό μήνυμα λάθους.
  -εάν η δοθείσα ημερομηνία εξόδου είναι μικρότερη ή ιση της υπάρχουσας entry date, η εντολή αγνοείται με σχετικό μήνυμα λάθους
  -εάν ο ασθενής είχε ήδη κάποιο exit date, η εντολή αλλάζει αυτό το exitdate σε αυτό που έδωσε ο χρήστης τηρώντας φυσικά τους παραπάνω περιορισμούς.

Για τα topk:
  Ακολουθήθηκε η προσέγγιση του instructor Ioannis Kalyvas στο piazza:
  "θεωρώ πιο σωστό να μην φέρνετε όλες τις ασθένειες που έχουν ίδιο αριθμό κρουσμάτων. Σε γενικές γραμμές όταν ένας client μιας εφαρμογής μας ζητήσει να δει 3 results θα πρέπει να παίρνει πίσω 3 results"
Για τα ερωτήματα αυτά χρησιμοποιώ επίσης μια απλή δομή simpleHT που αυτό που κάνει είναι να συγκεντρώνει από το δέντρο της χώρας που βρίσκομαι
όλες τις ασθένειες της χώρας με αριθμό κρουσμάτων τους και έπειτα περνά αυτά τα ζεύγη ονόματος-κρουσμάτων σε ένα binary heap.

Για τα ερωτήματα globalDiseaseStats, diseaseFrequency και γενικά όταν υπάρχουν ορίσματα date1 date2 χρησιμοποιείται επίσης μια επικουρική
κλάση search_container που αυτό που κάνει είναι να κάνει qualify/disqualify τις εγγραφές που χρειάζεται βάσει ημερομηνίας. Έπειτα κάνει populate τις δομές που χρειάζονται.

ΕΠΕΞΗΓΗΣΗ ΜΕΡΙΚΩΝ ΚΛΑΣΕΩΝ:

-Η δομή που κρατάω τις εγγραφές (ώστε να δεσμευτούν μόνο μια φορά) είναι ο recordHT.
Είναι ενας απλός hash table βάσει recordID. Αυτό παρόλο που είναι λιγότερο αποδοτικό στην εισαγωγή στοιχείου από μονή λίστα,
η εισαγωγή θα γίνει μόνο μια φορά οπότε καταλήγει να είναι χρονικά αποδοτικότερος για διαδικασίες
αναζήτησης, ενημέρωσης, κτλ.. Τα buckets του έχουν δείκτη σε εγγραφή και next.

-Το cdHashTable είναι η γενική μορφή του πιο σύνθετου hashtable που είναι και αυτός που ζητείται από την άσκηση
για disease κ country. Λαμβάνονται υπόψιν οι παράμετροι bucketsize κτλ και στο τέλους αυτόυ βρίσκονται και οι δείκτες στα δέντρα
ημερομηνιών, όπως ζητείται. Μέσω κληρονομικότητας, οι υπκατηγορίες diseasehashtable κ countryhashtable
απορροφούν τα γενικά του χαρακτηριστικά και λειτουργίες και τα εξειδικεύουν κατά τις ανάγκες τους
(Π.χ. insert εξατομικευμένη καθώς το κλειδί είναι διαφορετικό στις 2 περιπτώσεις).

-Για την υλοποίηση του σωρού χωρίς πίνακα (topk.h) κρατάω ένα δείκτη στον τελευταίο κόμβο
και ένα μετρητή κόμβων του σωρού. Η διαγραφή-εξαγωγή που δίνει τη ρίζα που έχει το μέγιστο στοιχείο (maxheap)
γίνεται με τοποθέτηση του τελευταίου στοιχείου ως νέα ρίζα και μετά γίνεται swim down κατάλληλα για τη διατήρηση του σωρού.
Στην εισαγωγή ενός κόμβου γίνεται το εξής : Εαν ο σωρός έχει Ν κόμβους, μετατρέπω τον αριθμό Ν+1 σε binary και σκιπάρω το most
significant bit. Έπειτα, αν βρίσκω 0 κατεβαίνω αριστερά, εάν είναι 1 κατεβαίνω δεξιά και φτάνω στη θέση που θα μπεί.
Μετά γίνετια swim up όσο χρειάζεται για τη διατήρηση του σωρού.

-Στο δέντρο των ημερομηνιών της άσκησης, για το ζήτημα του duplicate entrydate κρατείται λίστα σε κάθε κόμβο με δείκτες
στις εγγραφές που έχουν αυτό το entrydate για το συγκεκριμένο δέντρο.

-Ο simpleht είναι μια επικουρική δομή που δεν κάνει τίποτα περισσότερο από το να κάνει hash country or disease (για το topk-countries και topk-diseases, αντίστοιχα)
και "απορροφάει" τις εγγραφές του δέντρου ώστε εκεί να μένει μέσα μόνον χώρες/ασθένειες με τα κρούσματά τους και να τις χειριστεί
όπως πρέπει ο σωρός.

-Σημαντικό στοιχείο της άσκησης (και αυτό που εξασφαλίζει τη σωστή αποδέσμευση όλης της μνήμης) είναι
οι καλά σχεδιασμένοι destructors των κλάσεων που δεσμεύτηκαν δυναμικά. Η delete στη c++ καλεί πάντα τους destructors, εάν υπάρχουν.
Έτσι, για να διαγραφεί ένα δένδρο αρκεί να κάνουμε delete τη ρίζα του. Εάν στον destructor έχουμε βάλει delete left, delete right
τότε καλούνται με τη σειρά τους και οι destructors των παιδιών και των παιδιών τους and so on.


ΕΞΩΤΕΡΙΚΕΣ ΑΝΑΦΟΡΕΣ
Για hash function : https://stackoverflow.com/questions/16075271/hashing-a-string-to-an-integer-in-c
tokenization of string : https://stackoverflow.com/questions/49201654/splitting-a-string-with-multiple-delimiters-in-c
μετατροπή int σε array από bits:
https://stackoverflow.com/questions/31577866/c-convert-integer-to-binary-array
